[TOC]



# 联合类型（|）

如果希望一个变量可以支持多种类型，就可以用 `联合类型（union types） `来定义。

例如，一个变量既支持 number 类型，又支持 string 类型，就可以这么写：

```ts
let num: number | string

num = 8
num = 'eight'
```

联合类型大大提高了类型的可扩展性，但当 TS 不确定一个联合类型的变量到底是哪个类型的时候，**只能访问他们共有的属性和方法**。

如果直接访问 `length` 属性，`string` 类型上有，`number` 类型上没有，就报错了。



# 交叉类型（&）

如果要对对象形状进行扩展，可以使用交叉类型 `&`。

比如 Person 有 name 和 age 的属性，而 Student 在 name 和 age 的基础上还有 grade 属性，就可以这么写:

```ts
interface Person {
    name: string
    age: number
}

type Student = Person & { grade: number }
```

联合类型 `|` 是指可以取几种类型中的**任意一种**，而交叉类型 `&` 是指把几种类型**合并**起来。



# 类型别名（type）

类型别名（type aliase），听名字就很好理解，就是给类型起个别名。

类型别名用 `type` 关键字来书写，有了类型别名，我们书写 TS 的时候可以更加方便简洁。

比如下面这个例子，`getName` 这个函数接收的参数可能是字符串，可能是函数，就可以这么写。

```ts
type Name = string
type NameResolver = () => string
type NameOrResolver = Name | NameResolver          // 联合类型
function getName(n: NameOrResolver): Name {
    if (typeof n === 'string') {
        return n
    }
    else {
        return n()
    }
}
```

> 类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。 -- TS 文档

类型别名的用法如下，

```ts
type Name = string                              // 基本类型

type arrItem = number | string                  // 联合类型

const arr: arrItem[] = [1,'2', 3]

type Person = { 
  name: Name 
}

type Student = Person & { grade: number  }       // 交叉类型

type Teacher = Person & { major: string  } 

type StudentAndTeacherList = [Student, Teacher]  // 元组类型

const list:StudentAndTeacherList = [
  { name: 'lin', grade: 100 }, 
  { name: 'liu', major: 'Chinese' }
]
```



## type 和 interface 的区别

#### 两者相同点：

- 都可以定义一个对象或函数
- 都允许继承

#### 两者不同点：

- interface（接口） 是 TS 设计出来用于**定义对象类型**的。
- type 是**类型别名**，用于给**各种类型**定义别名，让 TS 写起来更简洁、清晰。
- interface可以合并重复声明(合并)，type 不行



### 都可以定义一个对象或函数

定义对象上文已经说了，我们来看一下如何定义函数。

```ts
type addType = (num1:number,num2:number) => number

interface addType {
    (num1:number,num2:number):number
}
// 这两种写法都可以定义函数类型
const add:addType = (num1, num2) => {
    return num1 + num2
}
```

### 都允许继承

我们定义一个 Person 类型和 Student 类型，**Student 继承自 Person**，可以有下面四种方式

```ts
// interface 继承 interface
interface Person { 
  name: string 
}
interface Student extends Person { 
  grade: number 
}
const person:Student = {
  name: 'lin',
  grade: 100
}
// type 继承 type
type Person = { 
  name: string 
}
type Student = Person & { grade: number  }   // 用交叉类型
// interface 继承 type
type Person = { 
  name: string 
}

interface Student extends Person { 
  grade: number 
}
// type 继承 interface
interface Person { 
  name: string 
}

type Student = Person & { grade: number  }   // 用交叉类型
```

**`interface` 使用 extends 实现继承， `type` 使用交叉类型实现继承**

### 合并重复声明：

```ts
interface Person {
    name: string
}

interface Person {         // 重复声明 interface，就合并了
    age: number
}

const person: Person = {
    name: 'lin',
    age: 18
}
```

重复声明 type ，就报错了

```ts
type Person = {
    name: string
}

type Person = {     // Duplicate identifier 'Person'
    age: number
}

const person: Person = {
    name: 'lin',
    age: 18
}
```

### 小结

这两者的区别说了这么多，其实本不该把这两个东西拿来做对比，他们俩是完全不同的概念。

interface 是**接口**，用于描述一个对象。

type 是**类型别名**，用于给各种类型定义别名，让 TS 写起来更简洁、清晰。

平时开发中，一般**使用组合或者交叉类型**的时候，用 type。

一般要用类的 **extends** 或 **implements** 时，用 interface。



# 类型保护

如果有一个 `getLength` 函数，入参是联合类型 `number | string`，返回入参的 length，

```ts
function getLength(arg: number | string): number {
    return arg.length
}
```

从上文可知，这么写会报错，因为 number 类型上没有 length 属性。

这个时候，类型保护（Type Guards）出现了，可以使用 `typeof` 关键字判断变量的类型。

我们把 getLength 方法改造一下，就可以精准地获取到 string 类型的 length 属性了，

```ts
function getLength(arg: number | string): number {
    if(typeof arg === 'string') {
        return arg.length
    } else {
        return arg.toString().length
    }
}
```

之所以叫类型保护，就是为了能够在不同的分支条件中缩小范围，这样我们代码出错的几率就大大降低了。



# 类型断言

使用类型断言来告诉 TS，我（开发者）比你（编译器）更清楚这个参数是什么类型，你就别给我报错了，

```TypeScript
function getLength(arg: number | string): number {
    const str = arg as string
    if (str.length) {
        return str.length
    } else {
        const number = arg as number
        return number.toString().length
    }
}
```

> 注意，类型断言不是类型转换，把一个类型断言成联合类型中不存在的类型会报错。



# 字面量类型

有时候，我们需要定义一些常量，就需要用到字面量类型，比如，

```TypeScript
type ButtonSize = 'mini' | 'small' | 'normal' | 'large'

type Sex = '男' | '女'
```
