[TOC]



# 泛型（<T>）

`泛型`（Generics），从字面上理解，泛型就是一般的，广泛的。

泛型是指在定义函数、接口或类的时候，不预先指定具体类型，而是在使用的时候再指定类型。

`泛型`中的 `T` 就像一个占位符、或者说一个变量，在使用的时候可以把定义的类型**像参数一样传入**，它可以**原封不动地输出**。

`泛型`**在成员之间提供有意义的约束**，这些成员可以是：函数参数、函数返回值、类的实例成员、类的方法等。

> # **TS 文档**
>
> 软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。
>
> **在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。**



## 泛型基本使用

泛型的语法是 `< >` 里写类型参数，一般可以用 `T` 来表示。

```TypeScript
function print<T>(arg:T):T {
    console.log(arg)
    return arg
}

// type写法
type Print = <T>(arg: T) => T
const printFn:Print = function print(arg) {
    console.log(arg)
    return arg
}

// interface 写法
interface Iprint<T> {
    (arg: T): T
}
function print<T>(arg:T) {
    console.log(arg)
    return arg
}
const myPrint: Iprint<number> = print
```

这样，我们就做到了输入和输出的类型统一，且可以输入输出任何类型。

泛型中的 T 就像一个占位符、或者说一个变量，在使用的时候可以把定义的类型**像参数一样传入**，它可以**原封不动地输出**。

> 泛型的写法对前端工程师来说是有些古怪，比如 `< >`  `T` ，但记住就好，只要一看到 `< >`，就知道这是泛型。

### 默认参数

如果要给泛型加默认参数，可以这么写：

```ts
interface Iprint<T = number> {
    (arg: T): T
}
function print<T>(arg:T) {
    console.log(arg)
    return arg
}

const myPrint: Iprint = print
```

### 处理多个函数参数

我们用 T 代表第 0 项的类型，用 U 代表第 1 项的类型。

```TypeScript
function swap<T, U>(tuple: [T, U]): [U, T]{
    return [tuple[1], tuple[0]]
}
```

这样就可以实现了**元组第 0 项和第 1 项类型的交换**。

### 函数副作用操作

我们希望调用 API 都**清晰的知道返回类型是什么数据结构**，可以这么做：

```TypeScript
interface UserInfo {
    name: string
    age: number
}
function request<T>(url:string): Promise<T> {
    return fetch(url).then(res => res.json())
}

// 传类型参数 T=UserInfo
request<UserInfo>('user/info').then(res =>{
    console.log(res)
})
```

这样就能很舒服地拿到接口返回的数据类型，开发效率大大提高。

### 约束泛型

通过 `extends` 实现对泛型的约束。

```ts
interface ILength {
    length: number
}
function printLength<T extends ILength>(arg: T): T {
    console.log(arg.length)
    return arg
}
```

### 泛型的一些应用

使用泛型，可以在定义函数、接口或类的时候，不预先指定具体类型，而是在使用的时候再指定类型。

特别注意的是，**泛型无法约束类的静态成员**。



# 泛型的高级用法

## 索引类型

### 索引查询（keyof）

`keyof` 操作符可以用于获取某种类型的所有键，其返回类型是联合类型。

```ts
interface IPerson {
  name: string;
  age: number;
}

type Test = keyof IPerson; // 'name' | 'age'
```

### 索引访问（T[K]）

`T[K]`，表示接口 T 的属性 K 所代表的类型。

```ts
interface IPerson {
  name: string;
  age: number;
}

let type1:  IPerson['name'] // string
let type2:  IPerson['age']  // number
```

### 泛型约束 (extends)

`T extends U`，表示泛型变量可以通过继承某个类型，获得某些属性。

> 需要注意：extends 运用在 type 和 class 中时完全是两种作用的效果。

```ts
interface ILength {
    length: number
}

function printLength<T extends ILength>(arg: T): T {
    console.log(arg.length)
    return arg
}
```



## 映射类型

TS允许**将一个类型映射成另外一个类型**。

### in

`in` 操作符，用来对联合类型实现遍历。

```ts
type Person = "name" | "school" | "major"
type Obj =  {
	[P in Person]: string
}
```



### Partial

`Partial<T>`将`T`的所有属性映射为可选的。

```ts
interface IPerson {
    name: string
    age: number
}
let p: Partial<IPerson> = {}
```

`Partial` 的实现用到了 `in` 和 `keyof`。

#### 原理

```ts
// Partial
type IPartial<T> = {
    [K in keyof T]?: T[K]
}
```

### Readonly

`Readonly<T>`将`T`的所有属性映射为只读的，例如：

```ts
interface IPerson {
  name: string
  age: number
}
let p: Readonly<IPerson> = {
  name: 'lin',
  age: 18
}
```

#### 原理

```ts
// Readonly
type IReadonly<T> = {
    readonly [K in keyof T]: T[K]
}
```

- `[K in keyof T]`遍历`T`上的所有属性
- `readonly`设置属性为只读的
- `T[K]`设置类型为原来的类型

### Pick

`Pick`用于抽取对象子集，挑选一组属性并组成一个新的类型，例如：

```ts
interface IPerson {
  name: string
  age: number
  sex: string
}
type IPick = Pick<IPerson, 'name' | 'age'>
let p: IPick = {
  name: 'lin',
  age: 18
}
```

这样就把 name 和 age 从 IPerson 中抽取出来。

#### 原理

```ts
type Pick<T, K extends keyof T> = {
    [P in K]: T[P]
}
```

### Record

上面三种映射类型官方称为`同态`, 意思是只作用于 obj 属性而不会引入新的属性。

`Record` 是会创建新属性的非同态映射类型。

```ts
interface IPerson {
  name: string
  age: number
}

type IRecord = Record<string, IPerson>

let personMap: IRecord = {
   person1: {
       name: 'lin',
       age: 18
   },
   person2: {
       name: 'liu',
       age: 25
   } 
}
```

#### 原理

```ts
type Record<K extends keyof any, T> = {
    [P in K]: T
}
```

Record 映射类型有两个参数:

- 第一个参数可以传入继承于 any 的任何值
- 第二个参数，作为新创建对象的值，被传入



## 条件类型

若 **类型U可赋值给类型T**,那么结果类型就是 X 类型,否则就是 Y 类型。

```ts
T extends U ? X : Y 
```

如何理解**可被赋值**？例如下面的类型声明与赋值：

```ts
const num: number = 1; // 可被赋值
const str: string = 2; // 不可被赋值
```

而条件类型的判断逻辑，和上面的 **可被赋值** 逻辑相同。

**当联合类型无法做出判断时**

```ts
type AB<T> = T extends 'x' ? 'a' : 'b';
AB('x' | 'y'); // "a" | "b"
```

当T是`联合类型`时，`TypeScript` 会做 **推迟解析条件类型** 的处理，具体表现为：

会对`联合类型T` 分别进行类型计算，并将最终的结果以`联合类型`返回。

### Exclude

Exclude 意思是不包含，`Exclude<T, U>` 会返回 `联合类型 T` 中不包含 `联合类型 U` 的部分。

```ts
type Test = Exclude<'a' | 'b' | 'c', 'a'>; // 'b' | 'c'
```

#### 原理

```ts
type Exclude<T, U> = T extends U ? never : T
```

- `never`表示一个不存在的类型
- `never`与其他类型的联合后，为其他类型

### Extract

`Extract<T, U>`提取联合类型 T 和联合类型 U 的所有 **交集**。

```ts
type Test = Extract<'key1' | 'key2', 'key1'> // 'key1'
```

#### 原理

```ts
type Extract<T, U> = T extends U ? T : never
```



# 常用的工具类型（Utility Types）

为了方便开发者使用， TypeScript 内置了一些常用的工具类型。

上文介绍的索引类型、映射类型和条件类型都是工具类型。

## Omit

`Omit<T, U>`从类型 `T` 中剔除 `U` 中的所有属性。

```ts
interface IPerson {
    name: string
    age: number
}

type IOmit = Omit<IPerson, 'age'>
```

**Omit 原理**

```ts
type Omit<T, K extends keyof any> = 
Pick<T, Exclude<keyof T, K>>
```

Pick用于挑选一组属性并组成一个新的类型，Omit 是剔除一些属性，留下剩余的，他们俩有点相反的感觉。

那么就可以用  Pick 和 Exclude 实现 Omit。

当然也可以不用 Pick 实现：

```ts
type Omit2<T, K extends keyof any> = {
  [P in Exclude<keyof T, K>]: T[P]
}
```



## NonNullable

`NonNullable<T>` 用来过滤类型中的 null 及 undefined 类型。

```ts
type T0 = NonNullable<string | number | undefined>; // string | number
type T1 = NonNullable<string[] | null | undefined>; // string[]
```

**NonNullable 原理**

```ts
type NonNullable<T> = T extends null | undefined ? never : T
```

- `never`表示一个不存在的类型
- `never`与其他类型的联合后，为其他类型



## Parameters

`Parameters` 获取函数的参数类型，将每个参数类型放在一个元组中。

```ts
type T1 = Parameters<() => string>  // []
type T2 = Parameters<(arg: string) => void>  // [string]
type T3 = Parameters<(arg1: string, arg2: number) => void> // [arg1: string, arg2: number]
```

**Parameters 原理**

```ts
type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never
```

在条件类型语句中，可以用 `infer` 声明一个类型变量并且对它进行使用。

- `Parameters`首先约束参数`T`必须是个函数类型
- 判断`T`是否是函数类型，如果是则使用`infer P`暂时存一下函数的参数类型，后面的语句直接用 P 即可得到这个类型并返回，否则就返回`never`



## ReturnType

`ReturnType` 获取函数的返回值类型。

```ts
type T0 = ReturnType<() => string>  // string
type T1 = ReturnType<(s: string) => void>  // void
```

**ReturnType 原理**

```ts
type IReturnType<T extends (...args: any) => any> = T extends (any) => infer P ? P : any
```

懂了 `Parameters`，也就懂了 `ReturnType`，

- `ReturnType`首先约束参数`T`必须是个函数类型
- 判断`T`是否是函数类型，如果是则使用`infer R`暂时存一下函数的返回值类型，后面的语句直接用 R 即可得到这个类型并返回，否则就返回`any`























